#include <asm-generic/ioctl.h>

typedef enum
{
    DISPIF_TYPE_DBI = 0,
    DISPIF_TYPE_DPI,
    DISPIF_TYPE_DSI,
    DISPIF_TYPE_DPI0,
    DISPIF_TYPE_DPI1,
    DISPIF_TYPE_DSI0,
    DISPIF_TYPE_DSI1,
    HDMI,
    HDMI_SMARTBOOK, 
    MHL
} MTKFB_DISPIF_TYPE;

typedef enum
{
    DISPIF_MODE_VIDEO = 0,
    DISPIF_MODE_COMMAND
} MTKFB_DISPIF_MODE;

// struct task_struct;
typedef struct mtk_dispif_info {
	unsigned int display_id;
	unsigned int isHwVsyncAvailable;
	MTKFB_DISPIF_TYPE displayType;
	unsigned int displayWidth;
	unsigned int displayHeight;
	unsigned int displayFormat;
	MTKFB_DISPIF_MODE displayMode;
	unsigned int vsyncFPS;
	unsigned int physicalWidth;
	unsigned int physicalHeight;
	unsigned int isConnected;
	unsigned int lcmOriginalWidth;	// this value is for DFO Multi-Resolution feature, which stores the original LCM Wdith
	unsigned int lcmOriginalHeight;	// this value is for DFO Multi-Resolution feature, which stores the original LCM Height
} mtk_dispif_info_t;

#define MTK_IOR(num, dtype) _IOR('O', num, dtype)
#define MTKFB_GET_DISPLAY_IF_INFORMATION MTK_IOR(90, mtk_dispif_info_t)






#include <unistd.h>

#define _LINUX_CAPABILITY_U32S_3     2
#define _KERNEL_CAPABILITY_U32S    _LINUX_CAPABILITY_U32S_3

typedef unsigned int u32;

typedef struct kernel_cap_struct {
	__u32 cap[_KERNEL_CAPABILITY_U32S];
} kernel_cap_t;

// struct key;
// struct thread_group_cred;
struct cred {
	int usage;
	uid_t uid;            /* real UID of the task */
	gid_t gid;            /* real GID of the task */
	uid_t suid;           /* saved UID of the task */
	gid_t sgid;           /* saved GID of the task */
	uid_t euid;           /* effective UID of the task */
	gid_t egid;           /* effective GID of the task */
	uid_t fsuid;          /* UID for VFS ops */
	gid_t fsgid;          /* GID for VFS ops */
	unsigned securebits;     /* SUID-less security management */
	kernel_cap_t cap_inheritable; /* caps our children can inherit */
	kernel_cap_t cap_permitted;  /* caps we're permitted */
	kernel_cap_t cap_effective;  /* caps we can actually use */
	kernel_cap_t cap_bset;       /* capability bounding set */
	// unsigned char jit_keyring;
	// struct key *thread_keyring;
	// struct key *request_key_auth;
	// struct thread_group_cred *tgcred;
	void *security;      /* subjective LSM security */
};

struct task_struct;
struct thread_info {
	unsigned long		flags;		/* low level flags */
	int			preempt_count;	/* 0 => preemptable, <0 => bug */
	unsigned long		addr_limit;	/* address limit */
	struct task_struct	*task;		/* main task structure */
};

struct task_security_struct {
	u32 osid;		/* SID prior to last execve */
	u32 sid;		/* current SID */
	u32 exec_sid;		/* exec SID */
	u32 create_sid;		/* fscreate SID */
	u32 keycreate_sid;	/* keycreate SID */
	u32 sockcreate_sid;	/* fscreate SID */
};